% !TeX encoding = UTF-8
% !TeX spellcheck = en_GB
% !TeX root = ../thesis.tex

\chapter{Background}
\label{chapter:background}

This Chapter provides a background and the motivation for development of Threat Detector. It outlines some of the fundamental gaps in the current mobile network monitoring and packet inspection systems and the unique challenges they faced which led to the creation on this novel approach. This chapter explains the initial idea of Threat Detector as a covering solution for the areas that other mobile monitoring systems are not presenting or strongly lacking in. Existing solutions, while useful in some certain cases, often struggle or completely fail to address key vital aspects such as packet-to-application mapping, real-time threat detection and reputation checking and user-friendly implementation of threat intelligence. Moreover, this chapter elaborates on the inherent difficulties in the implementation of the initial idea that make such an attempt using typical approaches close to impossible. Many of these restrictions stem from the android operating system, limitations of the available APIs, and complexities of handling network traffic without degrading performance or user experience. Additionally, selected code snippets and API usage are presented to illustrate the workings of such systems and to highlight the motivating reasons behind certain deviations that become necessary during the course of design and development of Threat Detector.

\section{Initial Idea}
Development of Threat Detector commenced as a stand-alone idea that integrates packet interception and monitoring,  cross-referencing packets and corresponding applications, along with real-time reputation check capabilities.

To achieve the aforementioned goals, Threat Detector should implement a VPN functionality to intercept network traffic while being able to route the packets back and forth between the source and destination IP addresses. Moreover, it should inspect the network traffic to find IP packet associations with each application based on their UID, and finally send a crafted inquiry to a reputation-check database such as AbuseIPDB to explore the maliciousness of device's outbound traffic while providing the user with real-time updates and notifications about any suspicious application activity.

After the full development of the application based on the initial idea, Threat Detector's abstract user interface should have supposedly look like the following figures.

\begin{figure}[H]
	\centering
	\begin{subfigure}{0.49\textwidth}
		\centering
		\includegraphics[width = \textwidth]{App - Monitor Page.png}
		\caption{Monitor Page}
		\label{fig:Monitor Page initial idea}
	\end{subfigure}
	\begin{subfigure}{0.49\textwidth}
		\centering
		\includegraphics[width = \textwidth]{App - Logs Page.png}
		\caption{Logs Page}
		\label{fig:Logs Page initial idea}
	\end{subfigure}
	\caption{Threat Detector UI based on initial idea}
	\label{fig:Threat Detector UI based on initial idea}
\end{figure}


\subsection{VpnService API - Android's VPN Functionality}
The APIs provided by android as an OS (Operating System) include a wide range that includes functions to handle network traffic based on the user context (e.g. normal or root). According to the android's  \href{https://developer.android.com/reference/android/net/VpnService}{\emph{official API documentation}}, the preferred approach towards network traffic interception is utilization of VpnService API. This API provides an active interception of network and internet traffic by routing the packets through a gateway (normally the default gateway of the device's NIC (Network Interface Card)). This implementation ensures that the commute of network packets takes place only through one communication path. As a result, inspection of network traffic can be carried out only on that gateway simplifying packet handling. 

As shown in the following code snippet provided on android \href{https://developer.android.com/develop/connectivity/vpn}{\emph{developer wrbsite}}, android system establishes a TUN (Tunnel) interface to route all the packets utilizing a VpnService builder and routes them though the localhost address.

\begin{figure}[H]
	\centering
	\includegraphics[width = \textwidth]{VpnService Builder Code Snippet.png}
	\caption{VpnService Builder Implementation}
	\label{fig:VpnService Builder Code Snippet.png}
\end{figure}

Using this VPN the user will be able to:
\begin{itemize}
	\item Read raw packets going through the established Virtual Private Network.
	\item Analyse or filter them.
	\item Apply inbound and outbound rules.
	\item Inject data into the commuting traffic.
\end{itemize}

In simpler terms, it acts as a virtual network adapter that android routes all the traffic through. This enables interception, monitoring, and packet modification before forwarding to its original destination.

\todo{add screenshots of VpnService code}


\subsection{Application Name and Icon Extraction}
As depicted in screenshots of the initial idea, the application name and possibly the its icon should be illustrated for a more user-friendly exhibition of outbound network connections and their originating applications.

Intercepted packets using android's VpnService API only provide source/destination IP address, ports, protocols, and payload data (normally encrypted via SSL/TLS). Thus, retrieving which application is responsible for the out-going transmission of a specific packet is not feasible.

In order to extract the application's name, the packet's UID (Linux user identifier) should be extracted. Subsequently, it should be mapped to the installed application package. For android is a Linux-based system, to access the UID required to extract the app-generated traffic, retrieving the content of tcp/udp virtual folder is necessary. The files are located in \emph{/proc/net/tcp or /proc/net/udp}. These files map network sockets to UIDs. Once the UID is extracted, it can be resolved to retrieve the application name via android's PackageManager API.

Simplified illustration:

Packet --> IP/Port --> /proc/net/* --> UID --> Package name --> App name


\subsection{Limitations and Problems}
The above-mentioned employment of VpnService alongside extraction of packet UIDs fullfils the requirements of the initial concept. However, implementing of a VPN through VpnService API and extracting packets' UIDs introduce several challenges which necessitates some modifications to the original idea.

\subsubsection{Routing Problem}
The way that a VPN service functions is to create a connection point between multiple networks and enables the transmission and reception of packets among systems within them. However, android's VpnService does not provide an automatic mechanism to redirect the incoming and outgoing packets.

The referenced implementation of VpnService from the official developer website also lacks the APIs that comply with guidelines vital for correct functionality of a VPN. As a result, additional modifications are needed to handle the packet redirection in a VPN system, designed on top of VpnService.

In the most VPN protocols including IPsec, network traffic is transmitted using encapsulated IP packets. This means an IP packet is placed inside another one which results in two distinct headers. Inner and outer headers. Inner header contains the original IP header and the payload, while the outer header is added for transport across the network and is removed once the packet reaches its destination.

A fully functional VPN that meets all the requirements of this approach needs determining a default gateway, routing all the traffic through it, transmitting packets across network using IP packet encapsulation, using other android APIs such as streams to correctly handle the incoming and outgoing TCP/UDP streams while ensuring efficient buffering. 

Unfortunately, since android does not provide the APIs for complete header management and packet redirection across network, its implementation requires all of the these steps to be carefully handled at the application level. Consequently, the utilization of android VpnService API for building a fully functional VPN is deemed impractical in this project, as its implementation deviates drastically from the original scope and objectives of this thesis.


\subsubsection{Application UID Extraction Problem}
As stated before, to determine the application name, from which the outbound internet packet originates, extracting the UID of the packet is necessary, which is only accessible via \emph{/proc} filesystem. 

Accessing \emph{/proc} filesystem is possible via the following approaches:

\begin{itemize}
	\item Having root access.
	\item Utilizing system-level permissions.
	\item Using native C programming to interface directly with the Linux kernel of the android device.
\end{itemize}


with root access and requires the device to be rooted. Another approach would be using some system-level permissions to access the virtual file. Unfortunately, this permission is only viable on android 10 and below.





\section{How PCAPdroid already does it all}
\todo{Show the PCAPdroid app and info about it from its website in the background section or similar}







\section{Integration with PCAPDroid}
However, based on the lack of native kotlin/java support and the inevitable need for manual implementation of packet redirection (out of thesis context), 

