% !TeX encoding = UTF-8
% !TeX spellcheck = en_GB
% !TeX root = ../thesis.tex

\chapter{Background}
\label{chapter:background}

This Chapter provides a background and the motivation for development of Threat Detector. It outlines some of the fundamental gaps in the current mobile network monitoring and packet inspection systems and the unique challenges they faced which led to the creation on this novel approach. This chapter explains the initial idea of Threat Detector as a covering solution for the areas that other mobile monitoring systems are not presenting or strongly lacking in. Existing solutions, while useful in some certain cases, often struggle or completely fail to address key vital aspects such as packet-to-application mapping, real-time threat detection and reputation checking and user-friendly implementation of threat intelligence. Moreover, this chapter elaborates on the inherent difficulties in the implementation of the initial idea that make such an attempt using typical approaches close to impossible. Many of these restrictions stem from the android operating system, limitations of the available APIs, and complexities of handling network traffic without degrading performance or user experience. Additionally, selected code snippets and API usage are presented to illustrate the workings of such systems and to highlight the motivating reasons behind certain deviations that become necessary during the course of design and development of Threat Detector.

\section{Initial Idea}
Development of Threat Detector commenced as a stand-alone idea that integrates packet interception and monitoring,  cross-referencing packets and corresponding applications, along with real-time reputation check capabilities.

To achieve the aforementioned goals, Threat Detector should implement a VPN functionality to intercept network traffic while being able to route the packets back and forth between the source and destination IP addresses. Moreover, it should inspect the network traffic to find IP packet associations with each application based on their UID, and finally send a crafted inquiry to a reputation-check database such as AbuseIPDB to explore the maliciousness of device's outbound traffic while providing the user with real-time updates and notifications about any suspicious application activity.

After the full development of the application based on the initial idea, Threat Detector's abstract user interface should have supposedly look like the following figures.

\begin{figure}[H]
	\centering
	\begin{subfigure}{0.49\textwidth}
		\centering
		\includegraphics[width = \textwidth]{App - Monitor Page.png}
		\caption{Monitor Page}
		\label{fig:Monitor Page initial idea}
	\end{subfigure}
	\begin{subfigure}{0.49\textwidth}
		\centering
		\includegraphics[width = \textwidth]{App - Logs Page.png}
		\caption{Logs Page}
		\label{fig:Logs Page initial idea}
	\end{subfigure}
	\caption{Threat Detector UI based on initial idea}
	\label{fig:Threat Detector UI based on initial idea}
\end{figure}


\subsection{VpnService API - Android's VPN Functionality}
The APIs provided by android as an OS (Operating System) include a wide range that includes functions to handle network traffic based on the user context (e.g. normal or root). According to the android's  \href{https://developer.android.com/reference/android/net/VpnService}{\emph{official API documentation}}, the preferred approach towards network traffic interception is utilization of VpnService API. This API provides an active interception of network and internet traffic by routing the packets through a gateway (normally the default gateway of the device's NIC (Network Interface Card)). This implementation ensures that the commute of network packets takes place only through one communication path. As a result, inspection of network traffic can be carried out only on that gateway simplifying packet handling. 

As shown in the following code snippet provided on android \href{https://developer.android.com/develop/connectivity/vpn}{\emph{developer wrbsite}}, android system establishes a TUN (Tunnel) interface to route all the packets utilizing a VpnService builder and routes them though the localhost address.

\begin{figure}[H]
	\centering
	\includegraphics[width = \textwidth]{VpnService Builder Code Snippet.png}
	\caption{VpnService Builder Implementation}
	\label{fig:VpnService Builder Code Snippet.png}
\end{figure}

Using this VPN the user will be able to:
\begin{itemize}
	\item Read raw packets going through the established Virtual Private Network.
	\item Analyse or filter them.
	\item Apply inbound and outbound rules.
	\item Inject data into the commuting traffic.
\end{itemize}

In simpler terms, it acts as a virtual network adapter that android routes all the traffic through. This enables interception, monitoring, and packet modification before forwarding to its original destination.

Here is a partial depiction of VpnService implementation in the initial idea:

\begin{figure}[H]
	\centering
	\begin{subfigure}{0.5\textwidth}
		\centering
		\includegraphics[width = \textwidth]{Initial idea VpnService API - 1.png}
		\caption{Defining Default Gateway}
		\label{fig:Defining Default Gateway}
	\end{subfigure}
	\begin{subfigure}{0.49\textwidth}
		\centering
		\includegraphics[width = \textwidth]{Initial idea VpnService API - 2.png}
		\caption{Reading Incoming/Outgoing Data}
		\label{fig:Reading Incoming/Outgoing Data}
	\end{subfigure}
	\caption{Usage of VpnService API}
	\label{fig:Usage of VpnService API}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width = \textwidth]{Initial idea VpnService API - 3.png}
	\caption{Extracting Destination IP Address from Raw Packets}
	\label{fig:Extracting Destination IP Address from Raw Packets}
\end{figure}

In the screenshots provided in Figure 2.3, you can see the VpnService builder implementation that is responsible to route all the traffic to the default gateway alongside a ParcelFileDescriptor. This is an android class that acts as a wrapper around a Linux file descriptor. A file descriptor is a handle used by the operating system to access files, sockets, pipes, and I/O resources. However, luckily android provides a high-level, safe, kotlin/java friendly version of that through ParcelFileDescriptor API. In this implementation, the ParcelFileDescriptor instance represents a virtual network interface created by VpnService to handle the transfer of packets through tunnelling.

Figure 2.4 depicts the extraction of destination IPv4 address from a raw IP packet header. This IP address will be parsed to a threat intelligence database for an inquiry regarding the maliciousness of the address.

\subsection{Application Name and Icon Extraction}
As depicted in screenshots of the initial idea, the application name and possibly the its icon should be illustrated for a more user-friendly exhibition of outbound network connections and their originating applications.

Intercepted packets using android's VpnService API only provide source/destination IP address, ports, protocols, and payload data (normally encrypted via SSL/TLS). Thus, retrieving which application is responsible for the out-going transmission of a specific packet is not feasible.

In order to extract the application's name, the packet's UID (Linux user identifier) should be extracted. Subsequently, it should be mapped to the installed application package. For android is a Linux-based system, to access the UID required to extract the app-generated traffic, retrieving the content of tcp/udp virtual folder is necessary. The files are located in \emph{/proc/net/tcp or /proc/net/udp}. These files map network sockets to UIDs. Once the UID is extracted, it can be resolved to retrieve the application name via android's PackageManager API.

Simplified illustration:

Packet --> IP/Port --> /proc/net/* --> UID --> Package name --> App name


\subsection{Limitations and Problems}
The above-mentioned employment of VpnService alongside extraction of packet UIDs fullfils the requirements of the initial concept. However, implementing of a VPN through VpnService API and extracting packets' UIDs introduce several challenges which necessitates some modifications to the original idea.

\subsubsection{Routing Problem}
The way that a VPN service functions is to create a connection point between multiple networks and enables the transmission and reception of packets among systems within them. However, android's VpnService does not provide an automatic mechanism to redirect the incoming and outgoing packets.

The referenced implementation of VpnService from the official developer website also lacks the APIs that comply with guidelines vital for correct functionality of a VPN. As a result, additional modifications are needed to handle the packet redirection in a VPN system, designed on top of VpnService.

In the most VPN protocols including IPsec, network traffic is transmitted using encapsulated IP packets. This means an IP packet is placed inside another one which results in two distinct headers. Inner and outer headers. Inner header contains the original IP header and the payload, while the outer header is added for transport across the network and is removed once the packet reaches its destination.

A fully functional VPN that meets all the requirements of this approach needs determining a default gateway, routing all the traffic through it, transmitting packets across network using IP packet encapsulation, using other android APIs such as streams to correctly handle the incoming and outgoing TCP/UDP streams while ensuring efficient buffering. 

Unfortunately, since android does not provide the APIs for complete header management and packet redirection across network, its implementation requires all of the these steps to be carefully handled at the application level. Consequently, the utilization of android VpnService API for building a fully functional VPN is deemed impractical in this project, as its implementation deviates drastically from the original scope and objectives of this thesis.


\subsubsection{Application UID Extraction Problem}
As stated before, to determine the application name, from which the outbound internet packet originates, extracting the UID of the packet is necessary, which is only accessible via \emph{/proc} filesystem. 

Accessing \emph{/proc} filesystem is possible via the following approaches:

\begin{itemize}
	\item Having root access.
	\item Utilizing system-level permissions.
	\item Using native C programming to interface directly with the Linux kernel of the android device.
\end{itemize}

From the above-mentioned options, none of them is feasible to use. Rooting the android device for a normal user brings along a lot of drawbacks including weakened security and extended susceptibility to various attack surfaces. Moreover, as of android version 11 and above, the system-level permissions are not viable. As a result, this approach works only on Android Q and below. 

Interfacing the Linux kernel using C language remains the only reliable and feasible option that network monitoring solutions such as PCAPdroid and Ant-Monitor employ. Implementing this however, is not feasible for this thesis. 


\section{How PCAPdroid already does it all}

Developing a network monitoring solution similar to \href{https://www.wireshark.org/}{\emph{Wireshark}} for mobile platforms has already been a topic of importance among enterprise personal by the emergence of Bring Your Own Device policy. As a result, applications such as PCAPdroid, Mobeye, and Ant-Monitor came to existence as a solution to give administrators some leverage examining the network activities.

Among the aforementioned solutions PCAPdroid is an open-source solution that has implemented a fully functional VPN along with an extensive interface with android's Linux kernel to thoroughly handle \emph{/proc} filesystem. Thus, PCAPdroid can be a suitable candidate to provide the underlying foundation for the correct functionality of Threat Detector. It has settings that can be adjusted for communication between the android device and the administration endpoint. It captures network traffic and stacks the information in a widely-known PCAP/PCAPNG formats that can be fed into other network inspection tools such as Wireshark though various communication methods. These methods include HTTP servers and TCP/UDP streams.

\begin{figure}[H]
	\centering
	\begin{subfigure}{0.49\textwidth}
		\centering
		\includegraphics[height=0.48\textheight, keepaspectratio]{PCAPdroid Traffic Dump Options.jpg}
		\caption{PCAPdroid Traffic Dump Options}
		\label{fig:PCAPdroid Traffic Dump Options}
	\end{subfigure}
	\begin{subfigure}{0.49\textwidth}
		\centering
		\includegraphics[height=0.48\textheight, keepaspectratio]{PCAPdroid Capture Settings.jpg}
		\caption{PCAPdroid Packet Capture Settings}
		\label{fig:PCAPdroid Packet Capture Settings}
	\end{subfigure}
	\caption{Usage of VpnService API}
	\label{fig:PCAPdroid Traffic Dump and Packet Capture Settings}
\end{figure}


As shown in the screenshots above with employment of TCP exporter functionality and activation of PCAPdroid extensions majority of the limitations and inherent restrictions that stem from android's ecosystem and architecture can be overcome. The TCP exporter enables information transfer using TCP protocol and PCAPdroid extensions provides the application package name that can be easily utilized to extract the application name and icon necessary to meet the original idea of this thesis project.

\section{Integration with PCAPDroid}
As explained, for Threat Detector to function properly and for the requirements of this thesis to be met, integration/implementation of an approach to route and intercept network traffic and access to /proc filesystem are of utmost importance. However, since a thorough execution of them is unfeasible for this project, integration of those functionalities through a communication medium can potentially be a proper solution. 

The following chapters provide a detailed discussion of the coordination between PCAPdroid and Threat Detector. In this setup, data is exchanged in the form of PCAP files via a local TCP server, thereby enabling Threat Detector to address functionalities that would otherwise be impractical to implement on its own.






