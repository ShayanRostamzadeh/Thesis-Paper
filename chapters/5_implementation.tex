% !TeX encoding = UTF-8
% !TeX spellcheck = en_GB
% !TeX root = ../thesis.tex

\chapter{Implementation}
\label{chapter:implementation}

\section{Overview}
This chapter explains the practical implementation of Threat Detector, which is a functionality extension of the open-source application PCAPdroid. The main objective of this implementation was to design a passive network monitoring solution that is capable of identifying the source application and the destination IP address of outbound internet packets, followed by an assessment of the potential risks those connections might bring along using AbuseIPDB as a threat intelligence platform.

The practical implementation of Threat Detector follows a modular architecture that separates the responsibilities of packet capture and processing, data retrieval, and visualization. Unlike PCAPdroid and similar solutions that focus on low-level packet capture and forwarding, Threat Detector does not implement its own VPN-based interception. Instead of doing so, it operates as a server application for PCAPdroid as its client through a local TCP server, which receives real-time information in PCAP format. This design and the subsequent implementation ensures Threat Detector remains lightweight and modular while keeping the focusness on data retrieval and presentation of network intelligence rather than traffic interception and manipulation.

The following sections describe the Threat Detector's system architecture, its internal components, and the integration with AbuseIPDB alongside the communication interface with PCAPdroid.

\section{System Architecture}
Threat Detector's system architecture consists of four main layers:

\begin{enumerate}
	\item \textbf{Traffic capture layer} which is handled by PCAPdroid using Android's VpnService API to capture network traffic and subsequently build a PCAP file based upon the captured information. 
	\item \textbf{Data transport layer}, handled by Threat Detector which is responsible for transmission of the captured data from PCAPdroid to Threat Detector using a local TCP socket.
	\item \textbf{Threat analysis layer}, implemented in Threat Detector which parses the data, queries AbuseIPDB, and assesses the reputation score.
	\item \textbf{Presentation layer} that is the graphical user interface responsible for depiction of the results and configuration options to the user/administrator.
\end{enumerate}

In this constellation, PCAPdroid acts as a data aggregator, while Threat Detector functions as a data processing and visualization unit.

Figure \cref{fig:architecture} shows this flow:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[
		node distance=1.5cm,
		every node/.style={align=center, font=\sffamily},
		process/.style={rectangle, rounded corners, draw=black, thick, minimum width=3.5cm, minimum height=1cm, fill=blue!10},
		io/.style={trapezium, trapezium left angle=70, trapezium right angle=110, draw=black, thick, fill=green!10, minimum height=1cm, minimum width=3.5cm},
		external/.style={rectangle, draw=black, thick, dashed, fill=gray!10, minimum width=3.5cm, minimum height=1cm},
		arrow/.style={thick, ->, >=stealth}
		]
		
		% Nodes
		\node[external] (network) {Device Network Stack};
		\node[process, below=of network] (pcapdroid) {PCAPdroid\\(VpnService + Packet Capture)};
		\node[process, below=of pcapdroid] (tcp) {TCP Exporter\\(PCAP/PCAPNG Stream)};
		\node[process, below=of tcp] (threatdetector) {Threat Detector App\\(TCP Server + Parser)};
		\node[process, below=of threatdetector] (abuseipdb) {AbuseIPDB API Query};
		\node[io, below=of abuseipdb] (ui) {User Interface\\(Results Display)};
		
		% Arrows
		\draw[arrow] (network) -- (pcapdroid);
		\draw[arrow] (pcapdroid) -- (tcp);
		\draw[arrow] (tcp) -- (threatdetector);
		\draw[arrow] (threatdetector) -- (abuseipdb);
		\draw[arrow] (abuseipdb) -- (ui);
		
		% Side label
		\node[align=left, right=1cm of tcp] (note) {
			\small \textbf{Local Communication:}\\
			TCP connection on 127.0.0.1:1234\\
			PCAPdroid â†’ Threat Detector
		};
		
	\end{tikzpicture}
	\caption{Overall system architecture showing the data flow from packet capture by PCAPdroid to IP reputation analysis, Own Creation}
	\label{fig:architecture}
\end{figure}


\section{Development Environment and Setup}
The implementation and the development of Threat Detector was carried out using Android Studio (Narwhal 3 Feature Drop | 2025.1.3) with target SDK (Software Development Kit) version 34 in mind. This project is programmed primarily in Kotlin providing modern language features and improved coroutine support for better asynchronous network operations. Moreover, this implementation also utilises Android's \emph{Jetpack Compose}\footnote{\url{https://developer.android.com/compose}} which is the state-of-the-art Android's recommended toolkit for building native UI. It centralizes the back-end and frond-end code simplifying the management of UI updates based on changes that take place on the back-end side.

Development of Threat Detector follows \emph{MVVM (Model-View-Viewmodel)}\footnote{\url{https://en.wikipedia.org/wiki/Model\%E2\%80\%93view\%E2\%80\%93viewmodel}} which is a modern architectural pattern in computer software that separates the development of a graphical user interface (view) and the business or back-end logic (model). According to \emph{Android's developer website}\footnote{\url{https://developer.android.com/topic/libraries/architecture/viewmodel}}, by using instance state mechanism provided by view model, the data is not destroyed upon configuration changes such as navigation between various activities. This ensures data persistent and addresses the configuration change issues that utilizing plain-class-approach introduces.

Testing was performed on a physical device (Samsung Galaxy S22 - Android 15) using the standard APIs available through Android Studio and the following external/third-party APIs:

\begin{itemize}
	\item \textbf{OKhttp\footnote{\url{https://github.com/square/okhttp}} \& Retrofit\footnote{\url{https://github.com/square/retrofit}}} for HTTP communication with AbuseIPDB.
	\item \textbf{GSON\footnote{\url{https://github.com/google/gson}}} for JSON parsing.
	\item \textbf{Material-Component\footnote{\url{https://m3.material.io/components}}} for user interface design.
\end{itemize}

Threat Detector targets Android 12 (API 31) and above to ensure compatibility with the majority of Android devices in use and alignment with new Android's permission and network models.


\section{PCAPdroid Configuration and Data Export}
In this setup PCAPdroid is configured to capture all the network traffic using its internal Android's VpnService implementation. This application supports multiple data export options including file-based (e.g. PCAP/PCAPNG) and network-based exports. For this approach, the TCP exporter and PCAP file format were selected.

The TCP exporter feature provided by PCAPdroid continuously streams packets in real time over a TCP connection socket. 

To activate the above-mentioned features, the user should specify:
\begin{itemize}
	\item \textbf{Export protocol}: TCP
	\item \textbf{Host}: 127.0.0.1 (local TCP Server)
	\item \textbf{Port}: 1234 (default port used in PCAPdroid's setting)
	\item \textbf{Format}: PCAP (PCAPdroid extensions should be activated in the captures section)
	\item \textbf{Interval}: None (Continues reception)
\end{itemize} 

After adjusting the settings mentioned above, when PCAPdroid is launched and activated, it automatically connects to the TCP server established by Threat Detector and continuously transmits captured data as soon as a session begins.

\clearpage

\section{TCP Server Implementation in Threat Detector}
One of the core functionalities of Threat Detector is its TCP server running locally on the Android device. It listens to the incoming connections on a specified port (default set to 1234 - an arbitrary port that does not have any conflicts with critical background services in Android systems) and handles each connection request in a separate thread.

Simplified version of the server implementation can be viewed in figure \cref{fig:Threat_Detector_Server_Pseudo_code} 

\begin{figure}[H]
	\centering
	\includegraphics[width = 1\textwidth]{TCP Server Psuducode.png}
	\caption{Threat Detector TCP Server Pseudo Code, Own Creation}
	\label{fig:Threat_Detector_Server_Pseudo_code}
\end{figure}

As shown in \cref{fig:Threat_Detector_Server_Pseudo_code}, when a connection is established, a coroutine (\texttt{GlobalScope}) starts the continues reception of data in PCAP file format. This is implemented using the \texttt{handleClient()} method to extract the low-level information such as destination IP address, timestamps, ports, protocols, and UIDs.

%Here a coroutine is used instead of a thread for a better performance and less overhead. Coroutines are lightweight and ensure a substantially improved performance when it comes to handling asynchronous tasks on Android.


\section{Parsing of Packet Data}
Even thought the packets arrive in PCAP format, the received data should be reconstructed. This can be carried out with the help of a custom parser developed based on the  \emph{documentations}\footnote{\url{https://emanuele-f.github.io/PCAPdroid/advanced_features\#45-pcapdroid-extensions}} provided for third-party usage by locating the trailer magic number. After the reception of a packet, the parser reconstructs PCAP packet information into a readable format for ease of data extraction.

\cref{fig:Full_Packet_Dump} shows extracted information including destination IP address alongside HEX-encoded values such as destination port number, source IP address, and the app UID.

\begin{figure}[H]
	\centering
	\includegraphics[width = 0.8\textwidth]{Full_Packet_Dump.png}
	\caption{PCAP File Packet Dump, Own Creation}
	\label{fig:Full_Packet_Dump}
\end{figure}


\begin{figure}[H]
	\centering
	\includegraphics[width = 0.8\textwidth]{FAANG_IP_Addresses.png}
	\caption{Method To Check IPs Against FAANG Addresses, Own Creation}
	\label{fig:FAANG_IP_Addresses}
\end{figure}

In \cref{fig:Full_Packet_Dump} the extracted information including the destination IP addresses are added to a queue for further analysis and queries from AbuseIPDB.

Worth to mention that the IP addresses are cached to prevent redundant API calls and they are filtered against FAANG (Facebook-Meta, Apple, Amazon, Netflix, Google) IP addresses that are frequently utilised by third-party applications to save API calls. This is illustrated in \cref{fig:FAANG_IP_Addresses}.


\section{Integration With AbuseIPDB API}
\emph{AbuseIPDB}\footnote{\url{https://www.abuseipdb.com/}} service provides a RESTful API to check the maliciousness of the IP addresses based on their public reports. Threat Detector uses this API to determine whether an IP address is potentially malicious.

The way Threat Detector queries the IP addresses is as follows:

\vspace{0.5cm}

\begin{lstlisting}[language=bash]
GET https://api.abuseipdb.com/api/v2/check?ipAddress={IP}&maxAgeInDays=90

Headers: "Key"
Key: <API key>
Accept: application/json
\end{lstlisting}

\vspace{0.5cm}

\cref{fig:OKHTTP_Builder} shows how the HTTP query is built in Threat Detector.

\begin{figure}[H]
	\centering
	\includegraphics[width = 1\textwidth]{OKHTTP_Builder.png}
	\caption{Querying IP Address using HTTP GET Method, Own Creation}
	\label{fig:OKHTTP_Builder}
\end{figure}


AbuseIPDB responses vary based on the type of request sent to the server. Different types of requests can be found in the official \emph{AbuseIPDB documentation}\footnote{\url{https://docs.abuseipdb.com/?shell\#introduction}}. 

The request used by Threat Detector is "CHECK endpoint" which yields the following JSON response as shown in \cref{fig:AbuseIPDB_Check_endpoint_response.png}.

\begin{figure}[H]
	\centering
	\includegraphics[width = 1\textwidth]{AbuseIPDB_Check_endpoint_response.png}
	\caption{An Example of AbuseIPDB JSON Response \cite{AbuseIPDBDocumentation}}
	\label{fig:AbuseIPDB_Check_endpoint_response.png}
\end{figure}

The reputation score, marked as \texttt{abuseConfidenceScore}, is then compared with a user-defined threshold stored in \texttt{SharedPreferences}. If the score exceeds the defined threshold, it is flagged as potentially malicious and is then followed by a notification process to inform the user.

\section{Data Storage and Application Configuration}
Threat Detector uses Android's \texttt{SharedPreferences}\footnote{\url{https://developer.android.com/training/data-storage/shared-preferences}} to store user's preferences on the device. 

These Preferences are as follows:
\begin{itemize}
	\item TCP server port
	\item Minimum Confidence Score that user considers to be malicious
	\item AbuseIPDB API key 
\end{itemize}

The application page that makes use of \texttt{SharePreferences} in Threat Detector is shown in \cref{fig:Threat_Detector_Settings_Page}.

\begin{figure}[H]
	\centering
	\includegraphics[width = 0.5\textwidth]{Threat_Detector_Settings_Page.jpg}
	\caption{Threat Detector Saved Preferences, Own Creation}
	\label{fig:Threat_Detector_Settings_Page}
\end{figure}

Android's \texttt{SharedPreferences} utilises a dictionary approach to store reusable and modifiable data onto the Android device. It requires a \emph{Key} and an associated \emph{Value} that will be stored in the application data folder. The use of \texttt{SharePreferences} is feasible when there is a small collection of information that does not justify the employment of a local database such as \emph{Room}\footnote{\url{https://developer.android.com/training/data-storage/room/}} which simplifies the implementation of an SQL database to store application-related information.

\cref{fig:SharedPreferences_Code} shows the use of \texttt{SharedPreferences} in Threat Detector.

\begin{figure}[H]
	\centering
	\includegraphics[width = 1\textwidth]{SharedPreferences_Code.png}
	\caption{Threat Detector SharedPreferences Kotlin Code, Own Creation}
	\label{fig:SharedPreferences_Code}
\end{figure}

This approach of storing settings and preferences avoids the complexity of establishment and management of a local database, for the application is designed to be lightweight.


\section{User Interface Implementation}
Threat Detector's user interface was designed based on \emph{Material Design 3}\footnote{\url{https://m3.material.io/}}. It is Google's open-source design system for building UI components with vibrant colours, contrasting shapes, flexible typography, and intuitive motion.

\clearpage

Threat Detector's interface consists of the following sections:
\begin{itemize}
	\item \textbf{Monitor Page - \cref{fig:Monitor_Page.jpg}:} provides the functionality to start/stop the local TCP server alongside depicting the server activation status and user-defined IP confidence score.
	\item \textbf{Logs Page - \cref{fig:Logs_Page}:} provides user with a scrollable list of the applications that attempted to communicate with external IP addresses. Each list Entry shows the application name and icon along with the IP address and its confidence score.
	\item \textbf{IP Details Page - \cref{fig:IP_Details_Page}:} depicts additional information regarding the queried IP address including the countries that the IP address has been reported in, categories of attack, source port, etc. 
	\item \textbf{API Exhaustion Page - \cref{fig:IP_Exhaustion_Page}:} it appears as a notification page when the user has exhausted the free daily API calls from AbuseIPDB.
	\item \textbf{Settings Page - \cref{fig:SharedPreferences_Code}:} it is used to save user's preferences such as TCP server port, API key, and minimum IP confidence score.
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{subfigure}{0.45\textwidth}
		\centering
		\includegraphics[width = \textwidth]{Monitor_Page.jpg}
		\caption{Monitor Page}
		\label{fig:Monitor_Page.jpg}
	\end{subfigure}
	\begin{subfigure}{0.45\textwidth}
		\centering
		\includegraphics[width = \textwidth]{Logs_Page.jpg}
		\caption{Logs Page}
		\label{fig:Logs_Page}
	\end{subfigure}
	\centering
	\caption{Screenshots from Threat Detector, Own Creation}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{subfigure}{0.45\textwidth}
		\centering
		\includegraphics[width = \textwidth]{IP_Details_Page.jpg}
		\caption{IP Details Page}
		\label{fig:IP_Details_Page}
	\end{subfigure}
	\begin{subfigure}{0.45\textwidth}
		\centering
		\includegraphics[width = \textwidth]{IP_Exhaustion_Page.jpg}
		\caption{IP Exhaustion Page}
		\label{fig:IP_Exhaustion_Page}
	\end{subfigure}
	\centering
	\caption{Screenshots from Threat Detector, Own Creation}
\end{figure}

The user interface components update dynamically as new incoming data is registered by the TCP server. This includes the real time automatic updates to modify the items shown in Logs page, the colour change indicating the server status in Monitor page, and the illustration of IP Exhaustion Page as a pop-up when the user runs out of free API calls.

\section{Communication Flow and Synchronization}
The communication between Threat Detector and its companion application, PCAPdroid, takes place in a purely local context. The TCP connection socket is established through a loopback interface provided by Android's basic APIs, which ensures that no external component is involved. The server runs in a background thread, so that managing its lifecycle and configuration changes do not block the main UI thread leading to performance flaws.

In the case that PCAPdroid disconnects, stops capturing, or even stops data transmission, the server automatically cleans up the socket and its associated stream buffers and waits for new connection requests. Moreover, error handling routines are also taken into consideration for detection of malformed packets and connection timeouts.

\section{Security and Privacy Consideration}
Threat Detector is designed with conservation of user's privacy in mind. All the captured network data is processed locally and nothing is uploaded to an external server, except AbuseIPDB which is strictly IP-based and does not contain any personal identifiers/information.

Some additional precautions include:
\begin{itemize}
	\item Secure storage of the API key in private application folder.
	\item Local communication is restricted to local host (127.0.0.1). 
	\item Use of HTTPS for external queries from AbuseIPDB.
	\item No conservation of raw PCAP data than real-time analysis.
\end{itemize}


\section{Performance Optimization}
Since Threat Detector operates in real time, efficiency of the operations were of concern.

To ensure an optimized functionality, the following strategies were adopted:

\begin{itemize}
	\item Asynchronous querying of AbuseIPDB utilising background threads to prevent UI blockage.
	\item Caching of the recent IP lookups to avoid redundant requests.
	\item Custom lightweight parsing of PCAP metadata instead of a full reconstruction of the packets.
	\item Use of \texttt{InputStream} and buffers to implement thread-safe queues for data reception.
\end{itemize}

\section{Limitations}
In spite of the successful implementation of Threat Detector, this application introduces some fundamental limitations that can be of importance for further development of such monitoring and reputation-checking solution.

The limitations are as follows:
\begin{itemize}
	\item Threat Detector is an extension for PCAPdroid meaning that it is totally dependent on PCAPdroid for packet capture and PCAP file construction; Threat Detector cannot operate independently and requires the installation of PCAPdroid on the same device.
	\item AbuseIPDB free subscription enforces query rate limits (1000 queries per day), which restricts large-scale monitoring. However, this limitation can be solved by subscribing to paid plans.
	\item Payload content inspection is not carried out since most of the applications use encryption (e.g. TLS/SSL) between endpoints.
	\item Use of \texttt{SharedPreferences} rather than a dedicated database restricts historical tracking of the modifications carried out on stored preferences.
\end{itemize}

\section{Summary}
The implementation of Threat Detector and its integration with PCAPdroid provide a practical solution for monitoring and assessing the network traffic on Android devices. Its modular design allows further development and integration with other security tools that make use of TCP connections for data transmission. It successfully leverages AbuseIPDB's reputation intelligence and effectively bridges the gap between low-level packet capture and real-time threat awareness and user notification.

While Threat Detector is a lightweight and privacy-preserving solution that implements threat intelligence, it lays the foundation for several enhancements such as IP blocking, application-specific payload visualization, and AI-based anomaly detection. 

Overall, this project illustrates the feasibility of real-time mobile traffic analysis in the form of a hybrid approach using open-source tools and external reputation-checking databases.



